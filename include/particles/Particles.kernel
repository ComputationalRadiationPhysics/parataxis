#pragma once

#include "xrtTypes.hpp"

#include <particles/memory/boxes/ParticlesBox.hpp>
#include <particles/Identifier.hpp>
#include <dimensions/DataSpace.hpp>
#include <dimensions/DataSpaceOperations.hpp>

namespace xrt {

    template<class T_MyFrame, class T_OtherFrame, class T_ManipulateFunctor, class Mapping>
    __global__ void kernelCloneParticles(PMacc::ParticlesBox<T_MyFrame, simDim> myBox, PMacc::ParticlesBox<T_OtherFrame, simDim> otherBox,
                                         T_ManipulateFunctor manipulateFunctor, Mapping mapper)
    {
        using namespace PMacc::particles::operations;

        __shared__ T_OtherFrame *frame;

        __shared__ T_MyFrame *myFrame;
        __shared__ bool isValid;
        typedef typename Mapping::SuperCellSize SuperCellSize;

        __syncthreads(); /*wait that all shared memory is initialized*/

        const PMacc::DataSpace<Mapping::Dim> block = mapper.getSuperCellIndex(Space(blockIdx));

        if (threadIdx.x == 0)
        {
            frame = &(otherBox.getFirstFrame(block, isValid));
            if (isValid)
            {
                //we have everything to clone
                myFrame = &(myBox.getEmptyFrame());
                //myBox.setAsFirstFrame(*myFrame, block);
            }
        }
        __syncthreads();
        while (isValid) //move over all Frames
        {
            auto parDest = (*myFrame)[threadIdx.x];
            auto parSrc  = (*frame)[threadIdx.x];
            assign(parDest, parSrc);

            const Space localCellIdx = block
                + PMacc::DataSpaceOperations<simDim>::map<SuperCellSize>(threadIdx.x)
                - mapper.getGuardingSuperCells() * SuperCellSize::toRT();
            manipulateFunctor(localCellIdx,
                              parDest, parSrc,
                              true, parSrc[PMacc::multiMask_] == 1);

            __syncthreads();

            if (threadIdx.x == 0)
            {
                myBox.setAsLastFrame(*myFrame, block);

                frame = &(otherBox.getNextFrame(*frame, isValid));
                if (isValid)
                {
                    myFrame = &(myBox.getEmptyFrame());
                }
            }
            __syncthreads();
        }
    }

}  // namespace xrt
