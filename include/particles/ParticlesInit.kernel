#pragma once

#include "xrtTypes.hpp"
#include <dimensions/DataSpaceOperations.hpp>
#include <particles/operations/SetAttributeToDefault.hpp>
#include <compileTime/conversion/ResolveAndRemoveFromSeq.hpp>
#include <algorithms/ForEach.hpp>
#include <nvidia/atomic.hpp>
#include <boost/mpl/vector.hpp>

namespace xrt{
namespace kernel{

#define isMaster (linearThreadIdx == 0)
    /**
     * Fills the grid with particles of T_Species
     *
     * Only call with border mapper (Assumes no thread handles guards)
     *
     * \tparam particleFillInfo Struct providing functions (or functors) for getting number of particles,
     *                          their position, phase and momentum. Must provide an init(Space2D) function
     *                          that is called first with the totalCellIdx of the plane where particles are
     *                          created. Must also provide int32_t getCount(timeStep),
     *                          float_D getPosition(numParticle), getPhase(timeStep), getMomentum(timeStep)
     *                          E.g. \see ParticleFillInfo
     * \tparam localOffset Offset to the total origin
     * \tparam particleBox ParticleBox where the particles should be put to
     * \tparam gId Global start id used for assigning the global IDs to the particles
     * \tparam mapper Mapping used for this kernel
     */
    template< typename T_Species, typename T_ParticleFillInfo, typename ParBox, class Mapping>
    __global__ void fillGridWithParticles(T_ParticleFillInfo particleFillInfo,
                                          const Space localOffset,
                                          ParBox particleBox,
                                          const uint32_t timeStep,
                                          const uint32_t numTimeSteps,
                                          uint32_t* gId,
                                          const Mapping mapper)
    {
        static_assert(Mapping::AreaType == PMacc::BORDER, "Only borders should be filled");
        typedef typename ParBox::FrameType FrameType;
        constexpr uint32_t frameSize = PMacc::math::CT::volume<SuperCellSize>::type::value;

        /* We try to not waste any space by first filling the "low" frame till its full
         * and then filling the "high" frame, which is a new, empty frame. To do this in
         * parallel we need both frame pointers (high might be NULL) and a counter
         */
        __shared__ FrameType *frameLow, *frameHigh;
        __shared__ uint32_t frameCounter, lastFrameSize;

        const Space threadIndex(threadIdx);
        const uint32_t linearThreadIdx = PMacc::DataSpaceOperations<simDim>::map<SuperCellSize>(threadIndex);
        const Space superCellIdx(mapper.getSuperCellIndex(Space(blockIdx)));

        /*get local cell idx  */
        const Space localCellIndex = (superCellIdx - mapper.getGuardingSuperCells()) * SuperCellSize::toRT() + threadIndex;

        const Space totalCellIdx = localOffset + localCellIndex;
        if(totalCellIdx[laserConfig::DIRECTION] != 0)
            return;
        const Space2D totalCellIdx2D = totalCellIdx.shrink<simDim - 1>(laserConfig::DIRECTION + 1);
        particleFillInfo.init(totalCellIdx2D);

        __shared__ int32_t blockCreatesParticles;
        if (isMaster)
        {
            /* Init shared vars */
            blockCreatesParticles = 0;
            frameLow = nullptr;
            frameHigh = nullptr;
            frameCounter = 0;
            /* Init frameLow if any and not full*/
            bool hasLastFrame;
            FrameType& tmpFrame = particleBox.getLastFrame(superCellIdx, hasLastFrame);
            if(hasLastFrame)
            {
                lastFrameSize = particleBox.getSuperCell(superCellIdx).getSizeLastFrame();
                if(lastFrameSize < frameSize)
                {
                    frameLow = &tmpFrame;
                    frameCounter = lastFrameSize;
                }
            }else
                lastFrameSize = 0;
        }
        __syncthreads();

        /* Invariant at this point:
         *    frameCounter == 0 (empty or no last frame)
         * OR frameCounter == lastFrameSize (when there is a last frame)
         */

        /* Iterate over all time steps */
        for(uint32_t t = timeStep; t < timeStep + numTimeSteps; ++t)
        {
            /* remaining number of particles to create for this time step */
            uint32_t numParsToCreate = particleFillInfo.getCount(t);
            if (numParsToCreate > 0)
                PMacc::nvidia::atomicAllExch(&blockCreatesParticles, 1); //one or more cells have particles to create

            __syncthreads();
            if (!blockCreatesParticles)
                continue; // if there is no particle which has to be created for this timestep

            /* distribute the particles of the current timestep within the cell */
            do
            {
                /* invariants at this point:
                 * frameCounter is in [0, frameSize)
                 * lastFrameSize is in [0, frameSize] with: 0 <=> empty or none; frameSize <=> full
                 * frameCounter == 0 <=> last frame empty OR does not exist OR is full
                 * frameCounter > 0 => frameCounter == lastFrameSize; Reason: frameCounter holds the index
                 *      of the next particle to insert which is always the end of the last frame
                 *      Note that frameCounter == 0 is a special case and frameCounter == frameSize is impossible
                 */
                PMacc::lcellId_t destParticleIdx;
                if(numParsToCreate)
                    destParticleIdx = PMacc::nvidia::atomicAllInc(&frameCounter);
                else
                    destParticleIdx = std::numeric_limits<PMacc::lcellId_t>::max(); /* just to be sure */
                __syncthreads();

                /* master thread will handle adding new frames */
                if (isMaster)
                {
                    blockCreatesParticles = 0; //clear flag
                    if(frameCounter > 0)
                    {
                        /* We have some particles, check that we have frames for them
                         * frameLow is always required, frameHigh only if not all particles fit into frameLow
                         */
                        if(!frameLow)
                        {
                            /* No low frame, this can only happen when we have no or a full last frame */
                            FrameType& tmpFrame = particleBox.getEmptyFrame();
                            frameLow = &tmpFrame;
                            particleBox.setAsLastFrame(tmpFrame, superCellIdx);
                        }
                        if(frameCounter > frameSize)
                        {
                            /* Not all particles fit into last frame -> Create another one */
                            FrameType& tmpFrame = particleBox.getEmptyFrame();
                            frameHigh = &tmpFrame;
                            particleBox.setAsLastFrame(tmpFrame, superCellIdx);
                            lastFrameSize = frameCounter - frameSize;
                        }else
                            lastFrameSize = frameCounter;
                    }
                }
                __syncthreads();

                if (numParsToCreate > 0)
                {
                    /* Do this first so we can use it as an index */
                    numParsToCreate--;

                    /* Get correct frame and index */
                    FrameType* myFrame;
                    if(destParticleIdx < frameSize)
                        myFrame = frameLow;
                    else
                    {
                        myFrame = frameHigh;
                        destParticleIdx -= frameSize;
                    }
                    assert(destParticleIdx < frameSize);
                    auto particle = (*myFrame)[destParticleIdx];

                    /* Initialize the attributes to their default values but exclude the ones we set manually afterwards (\see AttrToIgnore) */
                    {
                        typedef typename FrameType::ValueTypeSeq ParticleAttrList;
                        typedef bmpl::vector5<PMacc::multiMask, PMacc::localCellIdx, position<>, momentum, globalId> AttrToIgnore;
                        typedef typename PMacc::ResolveAndRemoveFromSeq<ParticleAttrList, AttrToIgnore>::type ParticleCleanedAttrList;

                        PMacc::algorithms::forEach::ForEach<ParticleCleanedAttrList, PMacc::SetAttributeToDefault<bmpl::_1> > setToDefault;
                        setToDefault(PMacc::forward(particle));
                    }
                    particle[PMacc::multiMask_] = 1;
                    particle[PMacc::localCellIdx_] = linearThreadIdx;
                    particle[position_]   = particleFillInfo.getPosition(numParsToCreate);
                    particle[startPhase_] = particleFillInfo.getPhase(t);
                    particle[momentum_]   = particleFillInfo.getMomentum(t);
                    particle[creationTime_] = t;
                    /* Add a global Id for debugging purposes */
                    particle[globalId_] = PMacc::nvidia::atomicAllInc(gId);

                    if (numParsToCreate > 0)
                        PMacc::nvidia::atomicAllExch(&blockCreatesParticles, 1); //one or more cell has particles to create
                }
                __syncthreads();
                /* Master thread updates frame pointers */
                if (isMaster)
                {
                    if(frameCounter >= frameSize)
                    {
                        /* frameLow is full --> new low frame is old high frame (might be none) */
                        frameLow = frameHigh;
                        frameHigh = nullptr;
                        /* Reduce counter accordingly. Note the >= check instead of > --> frameCounter CAN reach 0 */
                        frameCounter -= frameSize;
                    }
                }
                __syncthreads( );
            }while (blockCreatesParticles);
        }
        /* Finally we need to set the size of the last frame --> No need to fill any gaps */
        if(isMaster)
        {
            particleBox.getSuperCell(superCellIdx).setSizeLastFrame(lastFrameSize);
        }
    }
#undef isMaster

} // namespace kernel
} // namespace xrt
