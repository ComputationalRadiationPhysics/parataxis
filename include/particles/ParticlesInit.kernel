#pragma once

#include "xrtTypes.hpp"
#include <dimensions/DataSpaceOperations.hpp>
#include <particles/operations/SetAttributeToDefault.hpp>
#include <compileTime/conversion/ResolveAndRemoveFromSeq.hpp>
#include <algorithms/ForEach.hpp>
#include <nvidia/atomic.hpp>
#include <boost/mpl/vector.hpp>

namespace xrt{
namespace kernel{

    /**
     * Fills the grid with particles of T_Species
     *
     * \tparam distributionFunctor Should return the number of particles to create for a given totalGpuCellIdx (Space)
     * \tparam positionFunctor Must provide an init(Space totalGpuCellIdx, totalNumParsToCreate) which is called first.
     *                         Then is called for each particle, identified by its index in range [0, totalNumParsToCreate)
     *                         and should return the start position of the particle
     * \tparam localOffset Offset to the total origin
     * \tparam particleBox ParticleBox where the particles should be put to
     * \tparam gId Global start id used for assigning the global IDs to the particles
     * \tparam mapper Mapping used for this kernel
     */
    template< typename T_Species, typename T_DistributionFunctor, typename T_PositionFunctor, typename ParBox, class Mapping>
    __global__ void fillGridWithParticles(T_DistributionFunctor distributionFunctor,
                                          T_PositionFunctor positionFunctor,
                                          Space localOffset,
                                          ParBox particleBox,
                                          uint32_t* gId,
                                          Mapping mapper)
    {
        static_assert(Mapping::AreaType == PMacc::BORDER, "Only borders should be filled");
        typedef typename ParBox::FrameType FrameType;

        __shared__ FrameType *frame;

        const Space threadIndex(threadIdx);
        const uint32_t linearThreadIdx = PMacc::DataSpaceOperations<simDim>::map<SuperCellSize>(threadIndex);
        const Space superCellIdx(mapper.getSuperCellIndex(Space(blockIdx)));

        /* do not add particle to guarding super cells */
        const Space superCells(mapper.getGridSuperCells());
        for (uint32_t d = 0; d < simDim; ++d)
            if (superCellIdx[d] == 0 || superCellIdx[d] == superCells[d] - 1)
                return;

        /*get local cell idx and delete guarding cells */
        const Space localCellIndex = (superCellIdx - mapper.getGuardingSuperCells()) * SuperCellSize::toRT() + threadIndex;

        const Space totalCellIdx = localOffset + localCellIndex;
        const Space2D totalCellIdx2D(totalCellIdx.z(), totalCellIdx.y());
        const uint32_t totalNumParsToCreate = (totalCellIdx.x() == 0) ? distributionFunctor(totalCellIdx2D) : 0;

        __shared__ int32_t finished;
        if (linearThreadIdx == 0)
            finished = 1;
        __syncthreads();

        if (totalNumParsToCreate > 0)
            PMacc::nvidia::atomicAllExch(&finished, 0); //one or more cells have particles to create

        __syncthreads();
        if (finished == 1)
            return; // if there is no particle which has to be created

        if (linearThreadIdx == 0)
        {
            frame = &(particleBox.getEmptyFrame());
            particleBox.setAsLastFrame(*frame, superCellIdx);
        }

        positionFunctor.init(totalCellIdx, totalNumParsToCreate);
        /* remaining number of particles to create */
        uint32_t numParsToCreate = totalNumParsToCreate;

        // distribute the particles within the cell
        do
        {
            __syncthreads();
            if (linearThreadIdx == 0)
                finished = 1; //clear flag
            __syncthreads();

            if (numParsToCreate > 0)
            {
                auto particle = (*frame)[linearThreadIdx];

                /* Initialize the attributes to their default values but exclude the ones we set manually afterwards (\see AttrToIgnore) */
                {
                    typedef typename FrameType::ValueTypeSeq ParticleAttrList;
                    typedef bmpl::vector5<position<>, PMacc::multiMask, PMacc::localCellIdx, momentum, globalId> AttrToIgnore;
                    typedef typename PMacc::ResolveAndRemoveFromSeq<ParticleAttrList, AttrToIgnore>::type ParticleCleanedAttrList;

                    PMacc::algorithms::forEach::ForEach<ParticleCleanedAttrList, PMacc::SetAttributeToDefault<bmpl::_1> > setToDefault;
                    setToDefault(PMacc::forward(particle));
                }
                particle[PMacc::multiMask_] = 1;
                particle[PMacc::localCellIdx_] = linearThreadIdx;
                particle[position_] = positionFunctor(totalNumParsToCreate - numParsToCreate);
                particle[momentum_] = floatD_X(1, 0, 0);
                // Add a global Id for debugging purposes
                particle[globalId_] = PMacc::nvidia::atomicAllInc(reinterpret_cast<int32_t*>(gId));

                numParsToCreate--;
                if (numParsToCreate > 0)
                    PMacc::nvidia::atomicAllExch(&finished, 0); //one or more cell has particles to create
            }
            __syncthreads();
            if (linearThreadIdx == 0 && finished == 0)
            {
                frame = &(particleBox.getEmptyFrame());
                particleBox.setAsLastFrame(*frame, superCellIdx);
            }
        }
        while (finished == 0);
    }

} // namespace kernel
} // namespace xrt
