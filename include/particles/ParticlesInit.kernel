#pragma once

#include "xrtTypes.hpp"
#include <dimensions/DataSpaceOperations.hpp>
#include <particles/operations/SetAttributeToDefault.hpp>
#include <compileTime/conversion/ResolveAndRemoveFromSeq.hpp>
#include <algorithms/ForEach.hpp>
#include <nvidia/atomic.hpp>
#include <boost/mpl/vector.hpp>

namespace xrt{
namespace kernel{

    /**
     * Fills the grid with particles of T_Species
     *
     * \tparam particleFillInfo Struct providing functions (or functors) for getting number of particles,
     *                          their position, phase and momentum. Must provide an init(Space2D) function
     *                          that is called first with the totalCellIdx of the plane where particles are
     *                          created. Must also provide int32_t getCount(timeStep),
     *                          float_D getPosition(numParticle), getPhase(timeStep), getMomentum(timeStep)
     *                          E.g. \see ParticleFillInfo
     * \tparam localOffset Offset to the total origin
     * \tparam particleBox ParticleBox where the particles should be put to
     * \tparam gId Global start id used for assigning the global IDs to the particles
     * \tparam mapper Mapping used for this kernel
     */
    template< typename T_Species, typename T_ParticleFillInfo, typename ParBox, class Mapping>
    __global__ void fillGridWithParticles(T_ParticleFillInfo particleFillInfo,
                                          const Space localOffset,
                                          ParBox particleBox,
                                          const uint32_t timeStep,
                                          const uint32_t numTimeSteps,
                                          uint32_t* gId,
                                          const Mapping mapper)
    {
        static_assert(Mapping::AreaType == PMacc::BORDER, "Only borders should be filled");
        typedef typename ParBox::FrameType FrameType;

        __shared__ FrameType *frame;

        const Space threadIndex(threadIdx);
        const uint32_t linearThreadIdx = PMacc::DataSpaceOperations<simDim>::map<SuperCellSize>(threadIndex);
        const Space superCellIdx(mapper.getSuperCellIndex(Space(blockIdx)));

        /* do not add particle to guarding super cells */
        const Space superCells(mapper.getGridSuperCells());
        for (uint32_t d = 0; d < simDim; ++d)
            if (superCellIdx[d] == 0 || superCellIdx[d] == superCells[d] - 1)
                return;

        /*get local cell idx and delete guarding cells */
        const Space localCellIndex = (superCellIdx - mapper.getGuardingSuperCells()) * SuperCellSize::toRT() + threadIndex;

        const Space totalCellIdx = localOffset + localCellIndex;
        const Space2D totalCellIdx2D(totalCellIdx.z(), totalCellIdx.y());
        particleFillInfo.init(totalCellIdx2D);

        __shared__ int32_t blockCreatesParticles;
        if (linearThreadIdx == 0)
            blockCreatesParticles = 0;
        __syncthreads();

        /* Iterate over all time steps */
        for(uint32_t t = timeStep; t < timeStep + numTimeSteps; ++t)
        {
            /* remaining number of particles to create for this time step */
            int32_t numParsToCreate = particleFillInfo.getCount(t);
            if (numParsToCreate > 0)
                PMacc::nvidia::atomicAllExch(&blockCreatesParticles, 1); //one or more cells have particles to create

            __syncthreads();
            if (!blockCreatesParticles)
                continue; // if there is no particle which has to be created

            if (linearThreadIdx == 0)
            {
                frame = &(particleBox.getEmptyFrame());
                particleBox.setAsLastFrame(*frame, superCellIdx);
            }

            /* distribute the particles of the current timestep within the cell */
            do
            {
                if (linearThreadIdx == 0)
                    blockCreatesParticles = 0; //clear flag
                __syncthreads();

                if (numParsToCreate > 0)
                {
                    /* Do this first so we can use it as an index */
                    numParsToCreate--;
                    auto particle = (*frame)[linearThreadIdx];

                    /* Initialize the attributes to their default values but exclude the ones we set manually afterwards (\see AttrToIgnore) */
                    {
                        typedef typename FrameType::ValueTypeSeq ParticleAttrList;
                        typedef bmpl::vector5<PMacc::multiMask, PMacc::localCellIdx, position<>, momentum, globalId> AttrToIgnore;
                        typedef typename PMacc::ResolveAndRemoveFromSeq<ParticleAttrList, AttrToIgnore>::type ParticleCleanedAttrList;

                        PMacc::algorithms::forEach::ForEach<ParticleCleanedAttrList, PMacc::SetAttributeToDefault<bmpl::_1> > setToDefault;
                        setToDefault(PMacc::forward(particle));
                    }
                    particle[PMacc::multiMask_] = 1;
                    particle[PMacc::localCellIdx_] = linearThreadIdx;
                    particle[position_]   = particleFillInfo.getPosition(numParsToCreate);
                    particle[startPhase_] = particleFillInfo.getPhase(t);
                    particle[momentum_]   = particleFillInfo.getMomentum(t);
                    particle[creationTime_] = t;
                    /* Add a global Id for debugging purposes */
                    particle[globalId_] = PMacc::nvidia::atomicAllInc(gId);

                    if (numParsToCreate > 0)
                        PMacc::nvidia::atomicAllExch(&blockCreatesParticles, 1); //one or more cell has particles to create
                }
                __syncthreads();
                if (linearThreadIdx == 0 && blockCreatesParticles)
                {
                    frame = &(particleBox.getEmptyFrame());
                    particleBox.setAsLastFrame(*frame, superCellIdx);
                }
            }
            while (blockCreatesParticles);
        }
    }

} // namespace kernel
} // namespace xrt
